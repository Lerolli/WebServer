# WebServer - Задание 3
Многопоточный сервер на языке java

Цель данного упражнения познакомить студента с особенностями веб-сокетов в `Java` и построить веб-сервер будущего приложения.

В основе любого сетевого взаимодействия лежат сокеты Беркли, а их реализации существуют во всех языках программирования. В Java существует класс-абстракция над сокетами, а именно класс `ServerSocket`:

`ServerSocket server = new ServerSocket(int port)` — единственный параметр - порт, который сервер начинает слушать. Если создание серверного сокета завершилось успешно, то это означает, что порт успешно "захвачен" и сервер начал свою работу. В противном случае будет выброшено исключение.

Далее необходимо вызвать метод `accept()` - данный метод блокирует дальнейшее выполнение текущего потока до тех пор, пока не будет зарегистрировано входящее соединение. 

Пример кода:

```java
ServerScoket server = new ServerSocket(int port);
Socket client = server.accept(); - здесь происходит блокировка потока пока не появится входящее соединение. Переменная client - клиентский сокет.

InputStream in = client.getInputStream();    - здесь мы можем взять у клиентского сокета входящий поток и прочитать из него запрос подобно файлу.
    OutputStream out = client.getOutputStream(); - здесь мы можем взять у клиентского сокета исходящий поток и записать в него ответ на запрос.
```

Соответственно, легко понять что входящий поток на сервере - это исходящий поток на клиенте. А исходящий поток сервера - входящий клиента. В Java для чтения и записи из сокета используются потоки ввода-вывода. Следовательно, к ним можно применять различные "обертки" подобно работе с файлом. Необходимо учесть тот факт, что при пересылке большого количества данных необходимо использовать буферизированные "обертки" над потоками. Имеется ввиду случай, когда клиент еще не закончил писать запрос в поток, а сервер уже начал читать данные. В таком случае необходимы соглашения о формате и признаке конца запроса.

```java
Пример клиентского сокета:

Socket socket = new Socket(ipAddress, serverPort);
OutputStream out = socket.getOutputStream(); - сюда пишем запрос
InputStream in = socket.getInputStream();   - отсюда читаем ответ

```

Это основы, с которыми разобраться будет в общем случае несложно. Теперь несложно заметить, что построенный таким образом сервер является однопоточным - пока не будет вызван метод `accept()` — входящие соединения не будут приходить. Выходом из этой ситуации будет следующее:

1. Поместить метод `accept()`  внутрь бесконечного цикла.
2. Как только метод разблокируется, поместить клиентский сокет в другой поток, где будет обработан запрос, и благодаря пункту 1, сразу же перейти на новую итерацию цикла и снова вызвать метод `accept()`

Пример:

```java
ServerScoket server = new ServerSocket(int port);
while(true)
{
	Socket client = server.accept();
	<поместить client в другой поток>
}
```

Таким образом будет построен многопоточный веб-сервер.

Теперь можно переходить к формулировке задачи:
Дано:

1. FileWorker, способный считать хэш файлов.
2. ThreadDispather, способный ставить задачи на выполнение.
3. WebServer, многопоточный веб-сервер.

Необходимо с использованием все трех механизмов реализовать клиент-серверное приложение, в рамках которого поддерживаются два механизма работы:

1. Приложение занимает порт 8080 и отдает на этом порту http-контент. html-контент представляет собой файловый web-проводник. То есть необходимо через html-верстку реализвоать на странице переходы по папкам вглубь, назад, отображать список файлов в директории, каждый файл необходимо позволить скачать нажатием на соответствующую иконку напротив строки файла. Пример, который можно посмотреть: [https://download.qt.io](https://download.qt.io/) - как примерно могло бы выглядеть решение.
2. Приложение занимает порт 8081, на котором поднимается cli, позволяющая получать диагностику сервера:
    - list - получить список файлов в директории, на которую смотрит FileWorker.
    - hash <filename> - получить хэш соответствующего файла.
    - size <filename> - размер файла
    - status - статус работы сервера(active, stoped)
    - stop - остановить именно http-сервер
    - start - запустить http-сервер
3. С помощью ThreadDispatcher сервер выводит список активных потоков в серверную консоль.

То есть предельно простая логика - каждая команда отправляется с клиента, на сервере помещается в отдельный поток, в потоке обрабатывается - результат отправляется ответом на запрос и выводится в консоли клиента.

Главная цель упражения - необхождимо сообразно ООП построить основу серверной части будущего веб-прилолжения, правильно скомпоновав FileWorker, ThreadDispather, WebServer. Оцениваться будут прежде всего архитектура серверного приложения, наличие конфигурационных настроек (порт, ip-адрес...), механизмов корректной обработки запросов и ответов, механизма корректной остановки сервера. Клиент в данном случае имеет пока минимальную роль.

Тестирование: необходимо будет написать специальный тест, который будет с помощью ThreadDispather создавать одновременно запросы к серверу. На сервере же необходимо с помощью монитора потоков вывести список активных потоков, где должны быть более одного потока запроса. То есть на каждый запрос клиента монитор потоков должен реагировать. Ручное тестирование также будет проводиться.

# serializator - задание 4

Цель данного упражнения познакомить студента с особенностями reflection в Java/С# и реализовать сериализатор данных для клиент-серверного взаимодействия. Далее задача формулируется для Java. Сериализация - преобразование объекта в массив байтов. Десериализация - обратный процесс. Соотвественно, логика такая:

1. Создаем объект с данными.
2. Сериализуем объект с данными, получаем массив данных.
3. Отправляем массив байтов на сервер.
4. На сервере происходит десериализация обратно в объект.
5. Обработка данных.

То есть необходимо написать сериализатор данных для передачи по сети произвольного объекта.

ВАЖНО: с учетом того, что сервер и клиент могут быть на разных языках, то сериализатор должен существовать в каждом из них. Далее приводится сигнатура необходимых методов:

```java
public class Serializator {
	public byte[] Serialize(Object o)       перевод произвольного объекта в массив
	public T Deserialize<T>(byte[] raw)     перевод массива в объект.
	public AddCustom(Serializator custom)   добавление специального серилизатора для 
																					работы с произвольными типами, либо подмены 
																					дефолтной сериализации примитивных типов. 
																					Пример: DateTime.
}
```

Поскольку речь идет о разных языках, то необходимо сделать допущение. Будем исходить из того, что пересылаемый пакет с данными - это пакет с примитивными типами + строки.

Например:

```java
class Packet {
	int i;
	double d;
	string s;
	Packet p;
	Packet[] arr;
}
```

Общий подход состоит в том, что необходимо с помощью reflection'а перебрать все поля класса и записать их в массив по некой сигнатуре, например: [ид-типа][имя-поля][значение]. А затем, поскольку десериализация процесс обратный, просто распарсить массив и вернуть объект в исходное состоняие. Таким образом 4 байта int в Java  перейдут в 4 байта int в С#.

Необходимо сериализовать весь граф объекта. То есть, как в примере, если в объект вложен не примитивный тип, то необходимо войти в этот объект и сериализовать его поля. Если внутри есть сложный объект, то логика аналогичная. Очевидно, что структура класса Packet должна быть идентичной в обоих языках.

Запрещается пользоваться встроенными сериализаторами по типу автомапинга в json или xml.

Необходимо ввести маркер валидности. То есть не все, что приходит по сети, является пакетом. Проверка маркера валидности позволит определить, возможна ли десериализация в принципе.

Осуществить сериализацию массива сложных объектов. То есть, речь о сериализации поля вида Packet[] packets.

Выполнить исходную задачу с учетом оптимизаций так, чтобы на выходе получать минимального размера массив. Речь об алгоритмах сжатия, а также оптимальном формате записи самих данных

Подготовить серию тестов на разные типы объектов и степени вложенности
